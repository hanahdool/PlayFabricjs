<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <script src = "js/fabric.js"></script>
  <script src = "js/underscore.js"></script>
  <script src = "js/jquery.js"></script>
</head>
<body style="position:absolute">
<canvas id="canvas" style="border: 1px solid black;"></canvas>

<button id="addImage" onclick="addImage()">이미지 추가</button>
<button id="objectMode" onclick="objectMode()">object mode</button>
<button id="cropMode" onclick="cropMode()">crop mode</button>
<button id="crop" onclick="crop()">crop</button>
<br>
<button id="filpX" onclick="flipX()">좌우반전</button>
<button id="flipY" onclick="flipY()">상하반전</button>
<button id="initialize" onclick="initialize()">crop 영역 초기화</button>

<script>

  function flipX() {
    console.log('flipX');
    var active = canvas.getActiveObject();
    if (!active) return;
    active.flipX = active.flipX ? false : true;

    var origin = active._data.origin, crop_info = active._data.crop_info;
    origin.flipX = origin.flipX ? false : true;
    crop_info.flipX = crop_info.flipX ? false : true;
//    active._data.crop_info.flipX = origin.flipX; // 이렇게 하면 안되요!

    return canvas.renderAll();
  }

  function flipY() {
    console.log('flipY');
    var active = canvas.getActiveObject();
    if (!active) return;
    active.flipY = active.flipY ? false : true;

    var origin = active._data.origin, crop_info = active._data.crop_info;
    origin.flipY = origin.flipY ? false: true;
    crop_info.flipY = crop_info.flipY ? false : true;

    return canvas.renderAll();
  }






  var canvas = new fabric.Canvas('canvas');
  canvas.preserveObjectStacking = true;


  canvas.setHeight(800);
  canvas.setWidth(800);


//  addImage('image/wecan.png', 100, 100); // 경로, 위치x, 위치y
//  addImage('image/dog.png', 100, 100); // 경로, 위치x, 위치y
  addImage('image/icecream.png', 0, 0);


  function addImage(src, x, y) {

    /* 원본 */
    fabric.Image.fromURL(src, function(origin) { // fabric image 객체
      origin.set({
//        left: 0,
//        top: 0,
        //width: 400,
        //height: 400,
        scaleX: 1,
        scaleY: 1
      });
//    canvas.add(origin);

      /* cropped */
      var tmp = { // crop 정보
        top: 0,
        left: 0,
        width: origin.width,
        height: origin.height,
        //        multiplier: 2 // scale
//        flipX: false,
//        flipY: false
      };
      fabric.Image.fromURL(origin.toDataURL(tmp), function(cropped) {
        cropped.set({
          left: x,
          top: y,
          lockScalingFlip: true,
//          flipX: origin.flipX,
//          flipY: origin.flipY,
          /*, angle:origin.angle */
        });
        canvas.add(cropped).setActiveObject(cropped);
        cropped._data.crop_info = tmp;
        cropped._data.crop_info.index = canvas.getObjects().indexOf(cropped);

        /* cropper */
        var cropper = new fabric.Rect({
          top: cropped.top,
          left: cropped.left,
          width: cropped.width,
          height: cropped.height,
          fill: 'rgba(100, 100, 100, 0.2)',
//          fill: 'rgba(0,0,0,0)',
//          scaleX: img.scaleX,
//          scaleY: img.scaleY,
          borderColor: 'black',
          cornerColor: 'black',
          cornerSize: 8,
          borderDashArray: [5, 5],
          transparentCorners: false,
          hasRotatingPoint: false,
        globalCompositeOperation: 'lighter'
        });

        cropped._data.origin = origin;
        cropped._data.cropper = cropper;


      });


    }); // 이미지 로드(+ 콜백) 끝

  } // add Image 함수 끝



  function cropMode() {
    console.log("crop mode!");


    var cropped = canvas.getActiveObject();
    var crop_info = cropped._data.crop_info;


    var origin = cropped._data.origin;
    var cropper = cropped._data.cropper;
    var crop_info = cropped._data.crop_info;
//    crop_info.index = canvas.getObjects().indexOf(cropped);



    canvas.remove(cropped); // 왜 제거가 불안전하게 되지?



    // 원래 cropper는 여기 시점에서 아직까진 남아있음. - 근데 이동햇을 거잖아..-  그럼 crop_info!!

    console.log(crop_info.left, crop_info.top);
    var p = rotational_displacement({ x: cropped.left - crop_info.left, y: cropped.top - crop_info.top }, (cropped.angle - origin.angle), { x: cropped.left, y: cropped.top });
    origin.set({ // 원본 이미지
//      left: cropped.left - crop_info.left,
//      top: cropped.top - crop_info.top, // 이동만
//      left: cropped.left - crop_info.left * (1 + cropped.scaleX - origin.scaleX), // 뭔가 부정확함..
//      top: cropped.top - crop_info.top * (1 + cropped.scaleY - origin.scaleY), // 이동 + scaling만

      left: p.x,
      top: p.y, // 이동 + rotation만


      scaleX: cropped.scaleX,
      scaleY: cropped.scaleY,
//      width: , // 둘은 반드시 그대로 유지
//      height: ,
      angle: cropped.angle,

//      flipX: cropped.flipX, // 지워버리기
//      flipY: cropped.flipY,
//      flipX: crop_info.flipX,
//      flipY: crop_info.flipY,
    });


    // 회전했을 경우에는 또 여기에 회전한 만큼 값 이동시켜서 적용..
    if (crop_info.flipX) {
      console.log("좌우 뒤집힌 상태!");

      origin.left = cropper.left - ((cropper.left+cropper.width*cropper.scaleX) - (origin.left+origin.width*origin.scaleX));

    }
    if (crop_info.flipY) {
      console.log("위아래 뒤집힌 상태!");

      origin.top = cropper.top - ((origin.top+origin.height*origin.scaleY) - (cropper.top+cropper.height*cropper.scaleY));

    }




    cropper.set({ // 자르기
      top: cropped.top,
      left: cropped.left,
      width: cropped.width, // 여기는 상관x. 어짜피 다시 셋팅해줄 거니까
      height: cropped.height,
      scaleX: cropped.scaleX,
      scaleY: cropped.scaleY,

      angle: cropped.angle // 왜 안먹지?
    });

    cropper._data.cropped = cropped;
    cropper._data.origin = origin;
    cropper._data.crop_info = crop_info;

    canvas.add(origin);
    canvas.add(cropper);
    canvas.setActiveObject(cropper);
    canvas.renderAll();

  }





  function crop() {
    console.log("crop!");

    var cropper = canvas.getActiveObject();
    var origin = cropper._data.origin;
    var cropped = cropper._data.cropped;
    var sX = cropped.scaleX, sY = cropped.scaleY; // 나중에 더 깔끔하게 없애버리기

    origin.set({
      angle: 0, // crop할 때에는 다시 원위치로 시켜줘야 pattern이 이 origin 사용해서 알아서 잘 매핑함
      scaleX: cropped.scaleX,
      scaleY: cropped.scaleY,
//      flipX: cropped.flipX,
//      flipY: cropped.flipY,

    }); // 안해주면 패턴 씌울 때 기운 채로 매핑됨. (각도*2) 만큼

    // cropper 세팅
    cropper.set({
      width: cropper.width * cropper.scaleX, //this.width * this.scaleX
      height: cropper.height * cropper.scaleY,
      scaleX: 1,
      scaleY: 1
    });

    canvas.remove(cropped); //cropped = null;

    var np = rotational_displacement({ x: cropper.left, y: cropper.top}, -cropper.angle, { x: origin.left, y: origin.top});
    var crop_info = {
//      top: cropper.top-origin.top, // 크롬 위치 지정
//      left: cropper.left-origin.left,
      top: np.y - origin.top,
      left: np.x - origin.left,
      width: cropper.width,
      height: cropper.height,
    };

    fabric.Image.fromURL(origin.toDataURL(crop_info), function(cropped) {
      cropped.set({
        left: cropper.left,
        top: cropper.top,
        angle: cropper.angle,
        lockScalingFlip: true,
//        flipX: origin.flipX,
//        flipY: origin.flipY,

        scaleX: sX,
        scaleY: sY,

        width: cropper.width/sX, // width*sX = cropper.width // width = cropper.width/sX
        height: cropper.height/sY
      });
//      canvas.add(cropped).setActiveObject(cropped);
      canvas.insertAt(cropped, cropper._data.crop_info.index, false).setActiveObject(cropped); // obj, num, nonSplicing


      cropped._data.cropper = cropper;
      cropped._data.origin = origin;

      // 추가


      crop_info.index = cropper._data.crop_info.index;
      cropped._data.crop_info = crop_info;


//      origin.set({ // 이거 왜있는거지????????
//        top: cropped.top - (cropper.top - origin.top),
//        left: cropped.left - (cropper.left - ori origin.left),
//      });


      canvas.remove(cropper);
      canvas.remove(origin);

//      canvas.add(cropped);
      canvas.setActiveObject(cropped);

      canvas.renderAll();

      console.log("crop 완료!");


    })

  }


//  function expected_point(p, degree, a) { // rotational displacement
//
//    console.log(" 좌표 (전) : ", a.x, a.y);
//    p.y = -p.y;
//    a.y = -a.y;
//
//    var degree = Math.PI / 180 * degree; // 라디안 각도로 변환
//    var x, y;
//
//    x = (a.x - p.x)*Math.cos(degree) + (a.y - p.y)*Math.sin(degree) + p.x; // 행렬 곱하는 함수 있을 것 같음
//    y = (a.x - p.x)*Math.sin(degree) + (a.y - p.y)*Math.cos(degree) + p.y;
//
//
//    console.log(" 좌표 (후) : ", x, -y);
//
//    return { x: x, y: -y };
//
//  }

  function rotational_displacement(point, angle, center) { // 이동할 점, 각도, 중심점
    // 점center를 중심으로 점point를 angle만큼 회전시킨 결과를 리턴
    if (!center) center = { x: 0, y: 0 };
    angle = Math.PI/180*angle;

    var x, y;
    x = (point.x - center.x)*Math.cos(angle) - (point.y - center.y)*Math.sin(angle) + center.x;
    y = (point.x - center.x)*Math.sin(angle) + (point.y - center.y)*Math.cos(angle) + center.y;
    return { x, y };
  }







  function initialize() { // 이미지 처음 가져올 때랑 똑같음! - cropper 설정하고, flip, angle값만 바꾸고 다시 크롭!?!!!
    console.log("원본으로 복구!");

    var cropped = canvas.getActiveObject();


    // 아니면 cropped 설정 변경
    // - crop 함수에 인자 전달해주면 초기화 하도록 (=> 처음 로드할 때 같은 소스로 쓸 수 있음)




  }

</script>

</body>
</html>